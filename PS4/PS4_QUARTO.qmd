---
title: "Tarea IV"
subtitle: "Introducción a R - Programación II"
author:
  - "Nuria Saraí Torres Aldana"
  - "David Alejandro Del Cid De León"
  - "Diego Andrés Menendez Barillas"
date: today
format: 
  html:
    toc: true  
    code-fold: true
    toc-depth: 3
    theme: superhero
    smooth-scroll: false
  revealjs:
    theme: serif
    slide-number: true
    transition: slide
    incremental: true
---

**Programa de Estudios Superiores, Banco de Guatemala, 2025**

---

## CONFIGURACIÓN INICIAL


```{r setup}

rm(list = ls()) # Limpiar el entorno de R
graphics.off()  # Cerrar gráficos abiertos
cat("\014")
direccion <-""C:/Users/David del Cid/Desktop/Programacion II/PROGRA2/PS4"" 
setwd(direccion) # Establecer el directorio de trabajo
```

## LIMPIEZA Y VISUALIZACIÓN DE DATOS

### 1) En una tabla, muestre el número de hombres y el número de mujeres por departamento en Guatemala.

Tomando como base los datos del Censo de Población 2018, se realiza la limpieza de datos y selección de variables a utilizar para poder obtener el número de hombres y mujeres por departamento.

```{r Limpieza y Visualización de Datos}
# Cargamos la librerías necesarias
library(dplyr)
library(readr)
library(stringr)
library(data.table)
library(ggplot2)

# Cargar datos
datos <- data.table::fread(
    "PERSONA - BDP.csv",
    select = c("DEPARTAMENTO","COD_MUNICIPIO","PCP6","PCP7","ANEDUCA","PEA","POCUPA","PDESOC")
)
# Diccionarios
Nombre_Deptos <- c(
    "1"="Guatemala","2"="El Progreso","3"="Sacatepéquez","4"="Chimaltenango","5"="Escuintla",
    "6"="Santa Rosa","7"="Sololá","8"="Totonicapán","9"="Quetzaltenango","10"="Suchitepéquez",
    "11"="Retalhuleu","12"="San Marcos","13"="Huehuetenango","14"="Quiché","15"="Baja Verapaz",
    "16"="Alta Verapaz","17"="Petén","18"="Izabal","19"="Zacapa","20"="Chiquimula",
    "21"="Jalapa","22"="Jutiapa"
)
Sexo <- c("1"="Hombre","2"="Mujer")


# Transformación de tipo dato
datos <- datos %>%
    mutate(
        DEPARTAMENTO = str_replace_all(as.character(DEPARTAMENTO), Nombre_Deptos),
        PCP6 = str_replace_all(as.character(PCP6), Sexo))


# Inciso 1

# Ahora que los datos están limpios, creamos la tabla que pediste.
tabla_sexo_por_depto <- datos %>%
    # Agrupamos los datos primero por Departamento y luego por la columna de Sexo (PCP6).
    group_by(DEPARTAMENTO, PCP6) %>%
    # Contamos cuántas filas (personas) hay en cada grupo.
    # Usamos .groups = 'drop' para devolver un data.frame sin agrupaciones adicionales.
    summarise(Total = n(), .groups = 'drop') %>%
    # Reorganizamos la tabla para que los valores de PCP6 ("Hombre", "Mujer")
    # se conviertan en sus propias columnas.
    # Usamos values_fill = 0 para asegurar que las combinaciones faltantes se llenen con cero.
    pivot_wider(names_from = PCP6, values_from = Total, values_fill = 0) %>%
    # (Opcional) Ordenamos la tabla alfabéticamente por departamento.
    arrange(DEPARTAMENTO)
# Mostramos la tabla final
print(tabla_sexo_por_depto)

```

### 2) Utilizando OLS, estime el siguiente modelo: $td_i = \beta_0 + \beta_1\, \text{educ}_i + \varepsilon_i$

En esta segunda parte se crea el modelo de regresión lineal simple para estimar la tasa de desocupación del municipio de Guatemala tomando en cuenta los años de estudio promedio de la población.

```{r Simulación y Modelo}
datos_muni <- datos %>%
    group_by(DEPARTAMENTO, COD_MUNICIPIO) %>%
    summarise(
        PEA_total = sum(PEA, na.rm = TRUE),
        Desocupados_total = sum(POCUPA, na.rm = TRUE),
        td = Desocupados_total / PEA_total,
        educ = mean(ANEDUCA, na.rm = TRUE),
        .groups = "drop"
    ) %>%
    filter(PEA_total > 0)


modelo <- lm(td ~ educ, data = datos_muni)
summary(modelo)

```

### 3) Diagrama de dispersión para mostrar la relación entre la tasa de desocupación y los años de estudio promedio.

Utilizando la libreria ggplot podemos generar y modificar el gráfico deseado.

```{r Diagrama de Dispersión}

ggplot(datos_muni, aes(x = educ, y = td)) +
    geom_point(alpha = 0.6) +
    geom_smooth(method = "lm", se = TRUE, formula = y ~ x) +
    scale_y_continuous(labels = scales::percent_format(accuracy = 0.1)) +
    labs(
        title = "Relación entre educación promedio y tasa de desocupación",
        x = "Años promedio de estudio (municipio)",
        y = "Tasa de desocupación (%)"
    ) +
    theme_minimal(base_size = 13)
```

### 4) Replica de gráfica "Pirámide de Población a Nivel Nacional"

Se utiliza los datos aneriormente depurados se genera el gráfico a replicar.

```{r Pirámide de Población a Nivel Nacional}
#Generamos la función para simular AR(1)
simular_AR1 <- function(T, mu, rho, sigma2) {
  y <- numeric(T)
  epsilon_t <- numeric(T)
  y[1] <- rnorm(1, mean = mu / (1 - rho), sd = sqrt(sigma2 / (1 - rho^2)))
  for (t in 2:T) {
    epsilon_t <- rnorm(T, mean = 0, sd = sqrt(sigma2))
    y[t] <- mu + rho * y[t - 1] + epsilon_t[t]
  }
  return(y)
}

# Número de repeticiones para el experimento de Monte Carlo.
R <- 1000

# Creación de vectores numéricos vacíos para almacenar las estimaciones de cada parámetro por simulación.
mu_hat_vec     <- numeric(R)
rho_hat_vec    <- numeric(R)
sigma2_hat_vec <- numeric(R)

# Define los valores iniciales (el "punto de partida") que usará el optimizador.
valores_theta <- c(0.5, 0.5, 0.5)

# Inicia el bucle que se ejecutará desde r=1 hasta R.
for (r in 1:R) {
  
  # Simulación de Datos:
  # En cada iteración, se genera una NUEVA serie de tiempo AR(1) de tamaño T.
  y_r <- simular_AR1(T, mu_inicial, rho_inicial, sigma2_inicial)

  # Estimación por Máxima Verosimilitud (MLE):
  # Se utiliza la función optim() para encontrar los parámetros que maximizan la log-verosimilitud.
  theta_r <- optim(
    par     = valores_theta,           # Punto de partida para la búsqueda
    fn      = log_verosimilitud_AR1,   # La función a maximizar
    y       = y_r,                     # Los datos simulados en esta iteración
    method  = "L-BFGS-B",
    lower   = c(-Inf, -0.99, 1e-6),
    upper   = c( Inf,  0.99, Inf),
    control = list(fnscale = -1)
  )

  # Almacenamiento de Resultados:
  # Extrae el vector de parámetros estimados ('$par') y los guarda en la posición 'r' de los vectores de resultados.
  mu_hat_vec[r]     <- theta_r$par[1]
  rho_hat_vec[r]    <- theta_r$par[2]
  sigma2_hat_vec[r] <- theta_r$par[3]
}

# Cálculo del promedio de las R estimaciones para cada parámetro.
prom_mu  <- mean(mu_hat_vec)
prom_rho <- mean(rho_hat_vec)
prom_s2  <- mean(sigma2_hat_vec)

# Cálculo de la desviación estándar de las R estimaciones.
sd_mu  <- sd(mu_hat_vec)
sd_rho <- sd(rho_hat_vec)
sd_s2  <- sd(sigma2_hat_vec)
```


---